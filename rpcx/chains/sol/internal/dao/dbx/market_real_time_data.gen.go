// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dbx

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/simance-ai/smdx/rpcx/chains/sol/internal/dao/model"
)

func newMarketRealTimeDatum(db *gorm.DB, opts ...gen.DOOption) marketRealTimeDatum {
	_marketRealTimeDatum := marketRealTimeDatum{}

	_marketRealTimeDatum.marketRealTimeDatumDo.UseDB(db, opts...)
	_marketRealTimeDatum.marketRealTimeDatumDo.UseModel(&model.MarketRealTimeDatum{})

	tableName := _marketRealTimeDatum.marketRealTimeDatumDo.TableName()
	_marketRealTimeDatum.ALL = field.NewAsterisk(tableName)
	_marketRealTimeDatum.Address = field.NewString(tableName, "address")
	_marketRealTimeDatum.QuotePrice = field.NewFloat64(tableName, "quote_price")
	_marketRealTimeDatum.BasePrice = field.NewFloat64(tableName, "base_price")
	_marketRealTimeDatum.QuoteVault = field.NewFloat64(tableName, "quote_vault")
	_marketRealTimeDatum.BaseVault = field.NewFloat64(tableName, "base_vault")
	_marketRealTimeDatum.Liquidity = field.NewFloat64(tableName, "liquidity")
	_marketRealTimeDatum.MarketCap = field.NewFloat64(tableName, "market_cap")
	_marketRealTimeDatum.HolderCount = field.NewInt64(tableName, "holder_count")
	_marketRealTimeDatum.Swaps = field.NewInt64(tableName, "swaps")
	_marketRealTimeDatum.Sells = field.NewInt64(tableName, "sells")
	_marketRealTimeDatum.Buys = field.NewInt64(tableName, "buys")
	_marketRealTimeDatum.Volume = field.NewFloat64(tableName, "volume")
	_marketRealTimeDatum.PriceChange1m = field.NewFloat64(tableName, "price_change_1m")
	_marketRealTimeDatum.PriceChange5m = field.NewFloat64(tableName, "price_change_5m")
	_marketRealTimeDatum.PriceChange1h = field.NewFloat64(tableName, "price_change_1h")
	_marketRealTimeDatum.PriceChange6h = field.NewFloat64(tableName, "price_change_6h")
	_marketRealTimeDatum.PriceChange24h = field.NewFloat64(tableName, "price_change_24h")
	_marketRealTimeDatum.SellVolume1m = field.NewFloat64(tableName, "sell_volume_1m")
	_marketRealTimeDatum.SellVolume5m = field.NewFloat64(tableName, "sell_volume_5m")
	_marketRealTimeDatum.SellVolume1h = field.NewFloat64(tableName, "sell_volume_1h")
	_marketRealTimeDatum.SellVolume6h = field.NewFloat64(tableName, "sell_volume_6h")
	_marketRealTimeDatum.SellVolume24h = field.NewFloat64(tableName, "sell_volume_24h")
	_marketRealTimeDatum.BuyVolume1m = field.NewFloat64(tableName, "buy_volume_1m")
	_marketRealTimeDatum.BuyVolume5m = field.NewFloat64(tableName, "buy_volume_5m")
	_marketRealTimeDatum.BuyVolume1h = field.NewFloat64(tableName, "buy_volume_1h")
	_marketRealTimeDatum.BuyVolume6h = field.NewFloat64(tableName, "buy_volume_6h")
	_marketRealTimeDatum.BuyVolume24h = field.NewFloat64(tableName, "buy_volume_24h")
	_marketRealTimeDatum.BuyCount1m = field.NewFloat64(tableName, "buy_count_1m")
	_marketRealTimeDatum.BuyCount5m = field.NewFloat64(tableName, "buy_count_5m")
	_marketRealTimeDatum.BuyCount1h = field.NewFloat64(tableName, "buy_count_1h")
	_marketRealTimeDatum.BuyCount6h = field.NewFloat64(tableName, "buy_count_6h")
	_marketRealTimeDatum.BuyCount24h = field.NewFloat64(tableName, "buy_count_24h")
	_marketRealTimeDatum.SellCount1m = field.NewFloat64(tableName, "sell_count_1m")
	_marketRealTimeDatum.SellCount5m = field.NewFloat64(tableName, "sell_count_5m")
	_marketRealTimeDatum.SellCount1h = field.NewFloat64(tableName, "sell_count_1h")
	_marketRealTimeDatum.SellCount6h = field.NewFloat64(tableName, "sell_count_6h")
	_marketRealTimeDatum.SellCount24h = field.NewFloat64(tableName, "sell_count_24h")
	_marketRealTimeDatum.Age = field.NewTime(tableName, "age")
	_marketRealTimeDatum.PriceChange30m = field.NewFloat64(tableName, "price_change_30m")
	_marketRealTimeDatum.SellVolume30m = field.NewFloat64(tableName, "sell_volume_30m")
	_marketRealTimeDatum.BuyVolume30m = field.NewFloat64(tableName, "buy_volume_30m")
	_marketRealTimeDatum.BuyCount30m = field.NewFloat64(tableName, "buy_count_30m")
	_marketRealTimeDatum.SellCount30m = field.NewFloat64(tableName, "sell_count_30m")
	_marketRealTimeDatum.DevBaseBalance = field.NewFloat64(tableName, "dev_base_balance")
	_marketRealTimeDatum.Fdv = field.NewFloat64(tableName, "fdv")

	_marketRealTimeDatum.fillFieldMap()

	return _marketRealTimeDatum
}

type marketRealTimeDatum struct {
	marketRealTimeDatumDo marketRealTimeDatumDo

	ALL            field.Asterisk
	Address        field.String
	QuotePrice     field.Float64
	BasePrice      field.Float64
	QuoteVault     field.Float64 // 引用币数量
	BaseVault      field.Float64 // 基础币数量
	Liquidity      field.Float64 // 流动性大小usd
	MarketCap      field.Float64 // 市值 usd
	HolderCount    field.Int64
	Swaps          field.Int64
	Sells          field.Int64
	Buys           field.Int64
	Volume         field.Float64
	PriceChange1m  field.Float64
	PriceChange5m  field.Float64
	PriceChange1h  field.Float64
	PriceChange6h  field.Float64
	PriceChange24h field.Float64
	SellVolume1m   field.Float64
	SellVolume5m   field.Float64
	SellVolume1h   field.Float64
	SellVolume6h   field.Float64
	SellVolume24h  field.Float64
	BuyVolume1m    field.Float64
	BuyVolume5m    field.Float64
	BuyVolume1h    field.Float64
	BuyVolume6h    field.Float64
	BuyVolume24h   field.Float64
	BuyCount1m     field.Float64
	BuyCount5m     field.Float64
	BuyCount1h     field.Float64
	BuyCount6h     field.Float64
	BuyCount24h    field.Float64
	SellCount1m    field.Float64
	SellCount5m    field.Float64
	SellCount1h    field.Float64
	SellCount6h    field.Float64
	SellCount24h   field.Float64
	Age            field.Time
	PriceChange30m field.Float64
	SellVolume30m  field.Float64
	BuyVolume30m   field.Float64
	BuyCount30m    field.Float64
	SellCount30m   field.Float64
	DevBaseBalance field.Float64
	Fdv            field.Float64 // 流通市值

	fieldMap map[string]field.Expr
}

func (m marketRealTimeDatum) Table(newTableName string) *marketRealTimeDatum {
	m.marketRealTimeDatumDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m marketRealTimeDatum) As(alias string) *marketRealTimeDatum {
	m.marketRealTimeDatumDo.DO = *(m.marketRealTimeDatumDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *marketRealTimeDatum) updateTableName(table string) *marketRealTimeDatum {
	m.ALL = field.NewAsterisk(table)
	m.Address = field.NewString(table, "address")
	m.QuotePrice = field.NewFloat64(table, "quote_price")
	m.BasePrice = field.NewFloat64(table, "base_price")
	m.QuoteVault = field.NewFloat64(table, "quote_vault")
	m.BaseVault = field.NewFloat64(table, "base_vault")
	m.Liquidity = field.NewFloat64(table, "liquidity")
	m.MarketCap = field.NewFloat64(table, "market_cap")
	m.HolderCount = field.NewInt64(table, "holder_count")
	m.Swaps = field.NewInt64(table, "swaps")
	m.Sells = field.NewInt64(table, "sells")
	m.Buys = field.NewInt64(table, "buys")
	m.Volume = field.NewFloat64(table, "volume")
	m.PriceChange1m = field.NewFloat64(table, "price_change_1m")
	m.PriceChange5m = field.NewFloat64(table, "price_change_5m")
	m.PriceChange1h = field.NewFloat64(table, "price_change_1h")
	m.PriceChange6h = field.NewFloat64(table, "price_change_6h")
	m.PriceChange24h = field.NewFloat64(table, "price_change_24h")
	m.SellVolume1m = field.NewFloat64(table, "sell_volume_1m")
	m.SellVolume5m = field.NewFloat64(table, "sell_volume_5m")
	m.SellVolume1h = field.NewFloat64(table, "sell_volume_1h")
	m.SellVolume6h = field.NewFloat64(table, "sell_volume_6h")
	m.SellVolume24h = field.NewFloat64(table, "sell_volume_24h")
	m.BuyVolume1m = field.NewFloat64(table, "buy_volume_1m")
	m.BuyVolume5m = field.NewFloat64(table, "buy_volume_5m")
	m.BuyVolume1h = field.NewFloat64(table, "buy_volume_1h")
	m.BuyVolume6h = field.NewFloat64(table, "buy_volume_6h")
	m.BuyVolume24h = field.NewFloat64(table, "buy_volume_24h")
	m.BuyCount1m = field.NewFloat64(table, "buy_count_1m")
	m.BuyCount5m = field.NewFloat64(table, "buy_count_5m")
	m.BuyCount1h = field.NewFloat64(table, "buy_count_1h")
	m.BuyCount6h = field.NewFloat64(table, "buy_count_6h")
	m.BuyCount24h = field.NewFloat64(table, "buy_count_24h")
	m.SellCount1m = field.NewFloat64(table, "sell_count_1m")
	m.SellCount5m = field.NewFloat64(table, "sell_count_5m")
	m.SellCount1h = field.NewFloat64(table, "sell_count_1h")
	m.SellCount6h = field.NewFloat64(table, "sell_count_6h")
	m.SellCount24h = field.NewFloat64(table, "sell_count_24h")
	m.Age = field.NewTime(table, "age")
	m.PriceChange30m = field.NewFloat64(table, "price_change_30m")
	m.SellVolume30m = field.NewFloat64(table, "sell_volume_30m")
	m.BuyVolume30m = field.NewFloat64(table, "buy_volume_30m")
	m.BuyCount30m = field.NewFloat64(table, "buy_count_30m")
	m.SellCount30m = field.NewFloat64(table, "sell_count_30m")
	m.DevBaseBalance = field.NewFloat64(table, "dev_base_balance")
	m.Fdv = field.NewFloat64(table, "fdv")

	m.fillFieldMap()

	return m
}

func (m *marketRealTimeDatum) WithContext(ctx context.Context) *marketRealTimeDatumDo {
	return m.marketRealTimeDatumDo.WithContext(ctx)
}

func (m marketRealTimeDatum) TableName() string { return m.marketRealTimeDatumDo.TableName() }

func (m marketRealTimeDatum) Alias() string { return m.marketRealTimeDatumDo.Alias() }

func (m marketRealTimeDatum) Columns(cols ...field.Expr) gen.Columns {
	return m.marketRealTimeDatumDo.Columns(cols...)
}

func (m *marketRealTimeDatum) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *marketRealTimeDatum) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 45)
	m.fieldMap["address"] = m.Address
	m.fieldMap["quote_price"] = m.QuotePrice
	m.fieldMap["base_price"] = m.BasePrice
	m.fieldMap["quote_vault"] = m.QuoteVault
	m.fieldMap["base_vault"] = m.BaseVault
	m.fieldMap["liquidity"] = m.Liquidity
	m.fieldMap["market_cap"] = m.MarketCap
	m.fieldMap["holder_count"] = m.HolderCount
	m.fieldMap["swaps"] = m.Swaps
	m.fieldMap["sells"] = m.Sells
	m.fieldMap["buys"] = m.Buys
	m.fieldMap["volume"] = m.Volume
	m.fieldMap["price_change_1m"] = m.PriceChange1m
	m.fieldMap["price_change_5m"] = m.PriceChange5m
	m.fieldMap["price_change_1h"] = m.PriceChange1h
	m.fieldMap["price_change_6h"] = m.PriceChange6h
	m.fieldMap["price_change_24h"] = m.PriceChange24h
	m.fieldMap["sell_volume_1m"] = m.SellVolume1m
	m.fieldMap["sell_volume_5m"] = m.SellVolume5m
	m.fieldMap["sell_volume_1h"] = m.SellVolume1h
	m.fieldMap["sell_volume_6h"] = m.SellVolume6h
	m.fieldMap["sell_volume_24h"] = m.SellVolume24h
	m.fieldMap["buy_volume_1m"] = m.BuyVolume1m
	m.fieldMap["buy_volume_5m"] = m.BuyVolume5m
	m.fieldMap["buy_volume_1h"] = m.BuyVolume1h
	m.fieldMap["buy_volume_6h"] = m.BuyVolume6h
	m.fieldMap["buy_volume_24h"] = m.BuyVolume24h
	m.fieldMap["buy_count_1m"] = m.BuyCount1m
	m.fieldMap["buy_count_5m"] = m.BuyCount5m
	m.fieldMap["buy_count_1h"] = m.BuyCount1h
	m.fieldMap["buy_count_6h"] = m.BuyCount6h
	m.fieldMap["buy_count_24h"] = m.BuyCount24h
	m.fieldMap["sell_count_1m"] = m.SellCount1m
	m.fieldMap["sell_count_5m"] = m.SellCount5m
	m.fieldMap["sell_count_1h"] = m.SellCount1h
	m.fieldMap["sell_count_6h"] = m.SellCount6h
	m.fieldMap["sell_count_24h"] = m.SellCount24h
	m.fieldMap["age"] = m.Age
	m.fieldMap["price_change_30m"] = m.PriceChange30m
	m.fieldMap["sell_volume_30m"] = m.SellVolume30m
	m.fieldMap["buy_volume_30m"] = m.BuyVolume30m
	m.fieldMap["buy_count_30m"] = m.BuyCount30m
	m.fieldMap["sell_count_30m"] = m.SellCount30m
	m.fieldMap["dev_base_balance"] = m.DevBaseBalance
	m.fieldMap["fdv"] = m.Fdv
}

func (m marketRealTimeDatum) clone(db *gorm.DB) marketRealTimeDatum {
	m.marketRealTimeDatumDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m marketRealTimeDatum) replaceDB(db *gorm.DB) marketRealTimeDatum {
	m.marketRealTimeDatumDo.ReplaceDB(db)
	return m
}

type marketRealTimeDatumDo struct{ gen.DO }

func (m marketRealTimeDatumDo) Debug() *marketRealTimeDatumDo {
	return m.withDO(m.DO.Debug())
}

func (m marketRealTimeDatumDo) WithContext(ctx context.Context) *marketRealTimeDatumDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m marketRealTimeDatumDo) ReadDB() *marketRealTimeDatumDo {
	return m.Clauses(dbresolver.Read)
}

func (m marketRealTimeDatumDo) WriteDB() *marketRealTimeDatumDo {
	return m.Clauses(dbresolver.Write)
}

func (m marketRealTimeDatumDo) Session(config *gorm.Session) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Session(config))
}

func (m marketRealTimeDatumDo) Clauses(conds ...clause.Expression) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m marketRealTimeDatumDo) Returning(value interface{}, columns ...string) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m marketRealTimeDatumDo) Not(conds ...gen.Condition) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m marketRealTimeDatumDo) Or(conds ...gen.Condition) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m marketRealTimeDatumDo) Select(conds ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m marketRealTimeDatumDo) Where(conds ...gen.Condition) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m marketRealTimeDatumDo) Order(conds ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m marketRealTimeDatumDo) Distinct(cols ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m marketRealTimeDatumDo) Omit(cols ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m marketRealTimeDatumDo) Join(table schema.Tabler, on ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m marketRealTimeDatumDo) LeftJoin(table schema.Tabler, on ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m marketRealTimeDatumDo) RightJoin(table schema.Tabler, on ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m marketRealTimeDatumDo) Group(cols ...field.Expr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m marketRealTimeDatumDo) Having(conds ...gen.Condition) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m marketRealTimeDatumDo) Limit(limit int) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m marketRealTimeDatumDo) Offset(offset int) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m marketRealTimeDatumDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m marketRealTimeDatumDo) Unscoped() *marketRealTimeDatumDo {
	return m.withDO(m.DO.Unscoped())
}

func (m marketRealTimeDatumDo) Create(values ...*model.MarketRealTimeDatum) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m marketRealTimeDatumDo) CreateInBatches(values []*model.MarketRealTimeDatum, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m marketRealTimeDatumDo) Save(values ...*model.MarketRealTimeDatum) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m marketRealTimeDatumDo) First() (*model.MarketRealTimeDatum, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketRealTimeDatum), nil
	}
}

func (m marketRealTimeDatumDo) Take() (*model.MarketRealTimeDatum, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketRealTimeDatum), nil
	}
}

func (m marketRealTimeDatumDo) Last() (*model.MarketRealTimeDatum, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketRealTimeDatum), nil
	}
}

func (m marketRealTimeDatumDo) Find() ([]*model.MarketRealTimeDatum, error) {
	result, err := m.DO.Find()
	return result.([]*model.MarketRealTimeDatum), err
}

func (m marketRealTimeDatumDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MarketRealTimeDatum, err error) {
	buf := make([]*model.MarketRealTimeDatum, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m marketRealTimeDatumDo) FindInBatches(result *[]*model.MarketRealTimeDatum, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m marketRealTimeDatumDo) Attrs(attrs ...field.AssignExpr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m marketRealTimeDatumDo) Assign(attrs ...field.AssignExpr) *marketRealTimeDatumDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m marketRealTimeDatumDo) Joins(fields ...field.RelationField) *marketRealTimeDatumDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m marketRealTimeDatumDo) Preload(fields ...field.RelationField) *marketRealTimeDatumDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m marketRealTimeDatumDo) FirstOrInit() (*model.MarketRealTimeDatum, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketRealTimeDatum), nil
	}
}

func (m marketRealTimeDatumDo) FirstOrCreate() (*model.MarketRealTimeDatum, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketRealTimeDatum), nil
	}
}

func (m marketRealTimeDatumDo) FindByPage(offset int, limit int) (result []*model.MarketRealTimeDatum, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m marketRealTimeDatumDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m marketRealTimeDatumDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m marketRealTimeDatumDo) Delete(models ...*model.MarketRealTimeDatum) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *marketRealTimeDatumDo) withDO(do gen.Dao) *marketRealTimeDatumDo {
	m.DO = *do.(*gen.DO)
	return m
}
