// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dbx

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/simance-ai/smdx/rpcx/chains/sol/internal/dao/model"
)

func newMarketAuditMedium(db *gorm.DB, opts ...gen.DOOption) marketAuditMedium {
	_marketAuditMedium := marketAuditMedium{}

	_marketAuditMedium.marketAuditMediumDo.UseDB(db, opts...)
	_marketAuditMedium.marketAuditMediumDo.UseModel(&model.MarketAuditMedium{})

	tableName := _marketAuditMedium.marketAuditMediumDo.TableName()
	_marketAuditMedium.ALL = field.NewAsterisk(tableName)
	_marketAuditMedium.Address = field.NewString(tableName, "address")
	_marketAuditMedium.Name = field.NewString(tableName, "name")
	_marketAuditMedium.Description = field.NewString(tableName, "description")
	_marketAuditMedium.RenouncedFreezeAccount = field.NewBool(tableName, "renounced_freeze_account")
	_marketAuditMedium.RenouncedMint = field.NewBool(tableName, "renounced_mint")
	_marketAuditMedium.CreatorClose = field.NewBool(tableName, "creator_close")
	_marketAuditMedium.Top10HolderRate = field.NewFloat64(tableName, "top10_holder_rate")
	_marketAuditMedium.LpBurntRate = field.NewFloat64(tableName, "lp_burnt_rate")
	_marketAuditMedium.CreatorTokenStatus = field.NewBool(tableName, "creator_token_status")
	_marketAuditMedium.OfficialWebsite = field.NewString(tableName, "official_website")
	_marketAuditMedium.Telegram = field.NewString(tableName, "telegram")
	_marketAuditMedium.Twitter = field.NewString(tableName, "twitter")
	_marketAuditMedium.Facebook = field.NewString(tableName, "facebook")
	_marketAuditMedium.Reddit = field.NewString(tableName, "reddit")
	_marketAuditMedium.Github = field.NewString(tableName, "github")
	_marketAuditMedium.Whitepaper = field.NewString(tableName, "whitepaper")
	_marketAuditMedium.HotLevel = field.NewInt32(tableName, "hot_level")
	_marketAuditMedium.QuoteMaxSupply = field.NewFloat64(tableName, "quote_max_supply")

	_marketAuditMedium.fillFieldMap()

	return _marketAuditMedium
}

type marketAuditMedium struct {
	marketAuditMediumDo marketAuditMediumDo

	ALL                    field.Asterisk
	Address                field.String
	Name                   field.String
	Description            field.String
	RenouncedFreezeAccount field.Bool
	RenouncedMint          field.Bool
	CreatorClose           field.Bool
	Top10HolderRate        field.Float64
	LpBurntRate            field.Float64
	CreatorTokenStatus     field.Bool
	OfficialWebsite        field.String
	Telegram               field.String
	Twitter                field.String
	Facebook               field.String
	Reddit                 field.String
	Github                 field.String
	Whitepaper             field.String
	HotLevel               field.Int32
	QuoteMaxSupply         field.Float64

	fieldMap map[string]field.Expr
}

func (m marketAuditMedium) Table(newTableName string) *marketAuditMedium {
	m.marketAuditMediumDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m marketAuditMedium) As(alias string) *marketAuditMedium {
	m.marketAuditMediumDo.DO = *(m.marketAuditMediumDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *marketAuditMedium) updateTableName(table string) *marketAuditMedium {
	m.ALL = field.NewAsterisk(table)
	m.Address = field.NewString(table, "address")
	m.Name = field.NewString(table, "name")
	m.Description = field.NewString(table, "description")
	m.RenouncedFreezeAccount = field.NewBool(table, "renounced_freeze_account")
	m.RenouncedMint = field.NewBool(table, "renounced_mint")
	m.CreatorClose = field.NewBool(table, "creator_close")
	m.Top10HolderRate = field.NewFloat64(table, "top10_holder_rate")
	m.LpBurntRate = field.NewFloat64(table, "lp_burnt_rate")
	m.CreatorTokenStatus = field.NewBool(table, "creator_token_status")
	m.OfficialWebsite = field.NewString(table, "official_website")
	m.Telegram = field.NewString(table, "telegram")
	m.Twitter = field.NewString(table, "twitter")
	m.Facebook = field.NewString(table, "facebook")
	m.Reddit = field.NewString(table, "reddit")
	m.Github = field.NewString(table, "github")
	m.Whitepaper = field.NewString(table, "whitepaper")
	m.HotLevel = field.NewInt32(table, "hot_level")
	m.QuoteMaxSupply = field.NewFloat64(table, "quote_max_supply")

	m.fillFieldMap()

	return m
}

func (m *marketAuditMedium) WithContext(ctx context.Context) *marketAuditMediumDo {
	return m.marketAuditMediumDo.WithContext(ctx)
}

func (m marketAuditMedium) TableName() string { return m.marketAuditMediumDo.TableName() }

func (m marketAuditMedium) Alias() string { return m.marketAuditMediumDo.Alias() }

func (m marketAuditMedium) Columns(cols ...field.Expr) gen.Columns {
	return m.marketAuditMediumDo.Columns(cols...)
}

func (m *marketAuditMedium) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *marketAuditMedium) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 18)
	m.fieldMap["address"] = m.Address
	m.fieldMap["name"] = m.Name
	m.fieldMap["description"] = m.Description
	m.fieldMap["renounced_freeze_account"] = m.RenouncedFreezeAccount
	m.fieldMap["renounced_mint"] = m.RenouncedMint
	m.fieldMap["creator_close"] = m.CreatorClose
	m.fieldMap["top10_holder_rate"] = m.Top10HolderRate
	m.fieldMap["lp_burnt_rate"] = m.LpBurntRate
	m.fieldMap["creator_token_status"] = m.CreatorTokenStatus
	m.fieldMap["official_website"] = m.OfficialWebsite
	m.fieldMap["telegram"] = m.Telegram
	m.fieldMap["twitter"] = m.Twitter
	m.fieldMap["facebook"] = m.Facebook
	m.fieldMap["reddit"] = m.Reddit
	m.fieldMap["github"] = m.Github
	m.fieldMap["whitepaper"] = m.Whitepaper
	m.fieldMap["hot_level"] = m.HotLevel
	m.fieldMap["quote_max_supply"] = m.QuoteMaxSupply
}

func (m marketAuditMedium) clone(db *gorm.DB) marketAuditMedium {
	m.marketAuditMediumDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m marketAuditMedium) replaceDB(db *gorm.DB) marketAuditMedium {
	m.marketAuditMediumDo.ReplaceDB(db)
	return m
}

type marketAuditMediumDo struct{ gen.DO }

func (m marketAuditMediumDo) Debug() *marketAuditMediumDo {
	return m.withDO(m.DO.Debug())
}

func (m marketAuditMediumDo) WithContext(ctx context.Context) *marketAuditMediumDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m marketAuditMediumDo) ReadDB() *marketAuditMediumDo {
	return m.Clauses(dbresolver.Read)
}

func (m marketAuditMediumDo) WriteDB() *marketAuditMediumDo {
	return m.Clauses(dbresolver.Write)
}

func (m marketAuditMediumDo) Session(config *gorm.Session) *marketAuditMediumDo {
	return m.withDO(m.DO.Session(config))
}

func (m marketAuditMediumDo) Clauses(conds ...clause.Expression) *marketAuditMediumDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m marketAuditMediumDo) Returning(value interface{}, columns ...string) *marketAuditMediumDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m marketAuditMediumDo) Not(conds ...gen.Condition) *marketAuditMediumDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m marketAuditMediumDo) Or(conds ...gen.Condition) *marketAuditMediumDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m marketAuditMediumDo) Select(conds ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m marketAuditMediumDo) Where(conds ...gen.Condition) *marketAuditMediumDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m marketAuditMediumDo) Order(conds ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m marketAuditMediumDo) Distinct(cols ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m marketAuditMediumDo) Omit(cols ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m marketAuditMediumDo) Join(table schema.Tabler, on ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m marketAuditMediumDo) LeftJoin(table schema.Tabler, on ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m marketAuditMediumDo) RightJoin(table schema.Tabler, on ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m marketAuditMediumDo) Group(cols ...field.Expr) *marketAuditMediumDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m marketAuditMediumDo) Having(conds ...gen.Condition) *marketAuditMediumDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m marketAuditMediumDo) Limit(limit int) *marketAuditMediumDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m marketAuditMediumDo) Offset(offset int) *marketAuditMediumDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m marketAuditMediumDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *marketAuditMediumDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m marketAuditMediumDo) Unscoped() *marketAuditMediumDo {
	return m.withDO(m.DO.Unscoped())
}

func (m marketAuditMediumDo) Create(values ...*model.MarketAuditMedium) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m marketAuditMediumDo) CreateInBatches(values []*model.MarketAuditMedium, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m marketAuditMediumDo) Save(values ...*model.MarketAuditMedium) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m marketAuditMediumDo) First() (*model.MarketAuditMedium, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketAuditMedium), nil
	}
}

func (m marketAuditMediumDo) Take() (*model.MarketAuditMedium, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketAuditMedium), nil
	}
}

func (m marketAuditMediumDo) Last() (*model.MarketAuditMedium, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketAuditMedium), nil
	}
}

func (m marketAuditMediumDo) Find() ([]*model.MarketAuditMedium, error) {
	result, err := m.DO.Find()
	return result.([]*model.MarketAuditMedium), err
}

func (m marketAuditMediumDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MarketAuditMedium, err error) {
	buf := make([]*model.MarketAuditMedium, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m marketAuditMediumDo) FindInBatches(result *[]*model.MarketAuditMedium, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m marketAuditMediumDo) Attrs(attrs ...field.AssignExpr) *marketAuditMediumDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m marketAuditMediumDo) Assign(attrs ...field.AssignExpr) *marketAuditMediumDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m marketAuditMediumDo) Joins(fields ...field.RelationField) *marketAuditMediumDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m marketAuditMediumDo) Preload(fields ...field.RelationField) *marketAuditMediumDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m marketAuditMediumDo) FirstOrInit() (*model.MarketAuditMedium, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketAuditMedium), nil
	}
}

func (m marketAuditMediumDo) FirstOrCreate() (*model.MarketAuditMedium, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketAuditMedium), nil
	}
}

func (m marketAuditMediumDo) FindByPage(offset int, limit int) (result []*model.MarketAuditMedium, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m marketAuditMediumDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m marketAuditMediumDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m marketAuditMediumDo) Delete(models ...*model.MarketAuditMedium) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *marketAuditMediumDo) withDO(do gen.Dao) *marketAuditMediumDo {
	m.DO = *do.(*gen.DO)
	return m
}
