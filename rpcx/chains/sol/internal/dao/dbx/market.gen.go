// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dbx

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/simance-ai/smdx/rpcx/chains/sol/internal/dao/model"
)

func newMarket(db *gorm.DB, opts ...gen.DOOption) market {
	_market := market{}

	_market.marketDo.UseDB(db, opts...)
	_market.marketDo.UseModel(&model.Market{})

	tableName := _market.marketDo.TableName()
	_market.ALL = field.NewAsterisk(tableName)
	_market.ID = field.NewInt64(tableName, "id")
	_market.Address = field.NewString(tableName, "address")
	_market.CreatedTimestamp = field.NewTime(tableName, "created_timestamp")
	_market.OpenTimestamp = field.NewTime(tableName, "open_timestamp")
	_market.MarketType = field.NewString(tableName, "market_type")
	_market.BaseSymbol = field.NewString(tableName, "base_symbol")
	_market.BaseTokenAddress = field.NewString(tableName, "base_token_address")
	_market.BaseTokenMintAddress = field.NewString(tableName, "base_token_mint_address")
	_market.BaseTokenDecimals = field.NewInt32(tableName, "base_token_decimals")
	_market.QuoteSymbol = field.NewString(tableName, "quote_symbol")
	_market.QuoteTokenAddress = field.NewString(tableName, "quote_token_address")
	_market.QuoteTokenMintAddress = field.NewString(tableName, "quote_token_mint_address")
	_market.QuoteTokenDecimals = field.NewInt32(tableName, "quote_token_decimals")
	_market.DevAddress = field.NewString(tableName, "dev_address")
	_market.IsPump = field.NewBool(tableName, "is_pump")
	_market.InitBaseVault = field.NewFloat64(tableName, "init_base_vault")
	_market.InitQuoteVault = field.NewFloat64(tableName, "init_quote_vault")
	_market.LogoURL = field.NewString(tableName, "logo_url")
	_market.QuoteSupply = field.NewFloat64(tableName, "quote_supply")
	_market.InitBasePrice = field.NewFloat64(tableName, "init_base_price")
	_market.InitLiquidity = field.NewFloat64(tableName, "init_liquidity")
	_market.QuoteBurnSupply = field.NewFloat64(tableName, "quote_burn_supply")

	_market.fillFieldMap()

	return _market
}

type market struct {
	marketDo marketDo

	ALL                   field.Asterisk
	ID                    field.Int64
	Address               field.String
	CreatedTimestamp      field.Time
	OpenTimestamp         field.Time
	MarketType            field.String
	BaseSymbol            field.String
	BaseTokenAddress      field.String
	BaseTokenMintAddress  field.String
	BaseTokenDecimals     field.Int32
	QuoteSymbol           field.String
	QuoteTokenAddress     field.String
	QuoteTokenMintAddress field.String
	QuoteTokenDecimals    field.Int32
	DevAddress            field.String
	IsPump                field.Bool
	InitBaseVault         field.Float64
	InitQuoteVault        field.Float64
	LogoURL               field.String
	QuoteSupply           field.Float64
	InitBasePrice         field.Float64
	InitLiquidity         field.Float64
	QuoteBurnSupply       field.Float64

	fieldMap map[string]field.Expr
}

func (m market) Table(newTableName string) *market {
	m.marketDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m market) As(alias string) *market {
	m.marketDo.DO = *(m.marketDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *market) updateTableName(table string) *market {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt64(table, "id")
	m.Address = field.NewString(table, "address")
	m.CreatedTimestamp = field.NewTime(table, "created_timestamp")
	m.OpenTimestamp = field.NewTime(table, "open_timestamp")
	m.MarketType = field.NewString(table, "market_type")
	m.BaseSymbol = field.NewString(table, "base_symbol")
	m.BaseTokenAddress = field.NewString(table, "base_token_address")
	m.BaseTokenMintAddress = field.NewString(table, "base_token_mint_address")
	m.BaseTokenDecimals = field.NewInt32(table, "base_token_decimals")
	m.QuoteSymbol = field.NewString(table, "quote_symbol")
	m.QuoteTokenAddress = field.NewString(table, "quote_token_address")
	m.QuoteTokenMintAddress = field.NewString(table, "quote_token_mint_address")
	m.QuoteTokenDecimals = field.NewInt32(table, "quote_token_decimals")
	m.DevAddress = field.NewString(table, "dev_address")
	m.IsPump = field.NewBool(table, "is_pump")
	m.InitBaseVault = field.NewFloat64(table, "init_base_vault")
	m.InitQuoteVault = field.NewFloat64(table, "init_quote_vault")
	m.LogoURL = field.NewString(table, "logo_url")
	m.QuoteSupply = field.NewFloat64(table, "quote_supply")
	m.InitBasePrice = field.NewFloat64(table, "init_base_price")
	m.InitLiquidity = field.NewFloat64(table, "init_liquidity")
	m.QuoteBurnSupply = field.NewFloat64(table, "quote_burn_supply")

	m.fillFieldMap()

	return m
}

func (m *market) WithContext(ctx context.Context) *marketDo { return m.marketDo.WithContext(ctx) }

func (m market) TableName() string { return m.marketDo.TableName() }

func (m market) Alias() string { return m.marketDo.Alias() }

func (m market) Columns(cols ...field.Expr) gen.Columns { return m.marketDo.Columns(cols...) }

func (m *market) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *market) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 22)
	m.fieldMap["id"] = m.ID
	m.fieldMap["address"] = m.Address
	m.fieldMap["created_timestamp"] = m.CreatedTimestamp
	m.fieldMap["open_timestamp"] = m.OpenTimestamp
	m.fieldMap["market_type"] = m.MarketType
	m.fieldMap["base_symbol"] = m.BaseSymbol
	m.fieldMap["base_token_address"] = m.BaseTokenAddress
	m.fieldMap["base_token_mint_address"] = m.BaseTokenMintAddress
	m.fieldMap["base_token_decimals"] = m.BaseTokenDecimals
	m.fieldMap["quote_symbol"] = m.QuoteSymbol
	m.fieldMap["quote_token_address"] = m.QuoteTokenAddress
	m.fieldMap["quote_token_mint_address"] = m.QuoteTokenMintAddress
	m.fieldMap["quote_token_decimals"] = m.QuoteTokenDecimals
	m.fieldMap["dev_address"] = m.DevAddress
	m.fieldMap["is_pump"] = m.IsPump
	m.fieldMap["init_base_vault"] = m.InitBaseVault
	m.fieldMap["init_quote_vault"] = m.InitQuoteVault
	m.fieldMap["logo_url"] = m.LogoURL
	m.fieldMap["quote_supply"] = m.QuoteSupply
	m.fieldMap["init_base_price"] = m.InitBasePrice
	m.fieldMap["init_liquidity"] = m.InitLiquidity
	m.fieldMap["quote_burn_supply"] = m.QuoteBurnSupply
}

func (m market) clone(db *gorm.DB) market {
	m.marketDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m market) replaceDB(db *gorm.DB) market {
	m.marketDo.ReplaceDB(db)
	return m
}

type marketDo struct{ gen.DO }

func (m marketDo) Debug() *marketDo {
	return m.withDO(m.DO.Debug())
}

func (m marketDo) WithContext(ctx context.Context) *marketDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m marketDo) ReadDB() *marketDo {
	return m.Clauses(dbresolver.Read)
}

func (m marketDo) WriteDB() *marketDo {
	return m.Clauses(dbresolver.Write)
}

func (m marketDo) Session(config *gorm.Session) *marketDo {
	return m.withDO(m.DO.Session(config))
}

func (m marketDo) Clauses(conds ...clause.Expression) *marketDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m marketDo) Returning(value interface{}, columns ...string) *marketDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m marketDo) Not(conds ...gen.Condition) *marketDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m marketDo) Or(conds ...gen.Condition) *marketDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m marketDo) Select(conds ...field.Expr) *marketDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m marketDo) Where(conds ...gen.Condition) *marketDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m marketDo) Order(conds ...field.Expr) *marketDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m marketDo) Distinct(cols ...field.Expr) *marketDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m marketDo) Omit(cols ...field.Expr) *marketDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m marketDo) Join(table schema.Tabler, on ...field.Expr) *marketDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m marketDo) LeftJoin(table schema.Tabler, on ...field.Expr) *marketDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m marketDo) RightJoin(table schema.Tabler, on ...field.Expr) *marketDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m marketDo) Group(cols ...field.Expr) *marketDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m marketDo) Having(conds ...gen.Condition) *marketDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m marketDo) Limit(limit int) *marketDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m marketDo) Offset(offset int) *marketDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m marketDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *marketDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m marketDo) Unscoped() *marketDo {
	return m.withDO(m.DO.Unscoped())
}

func (m marketDo) Create(values ...*model.Market) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m marketDo) CreateInBatches(values []*model.Market, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m marketDo) Save(values ...*model.Market) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m marketDo) First() (*model.Market, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Market), nil
	}
}

func (m marketDo) Take() (*model.Market, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Market), nil
	}
}

func (m marketDo) Last() (*model.Market, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Market), nil
	}
}

func (m marketDo) Find() ([]*model.Market, error) {
	result, err := m.DO.Find()
	return result.([]*model.Market), err
}

func (m marketDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Market, err error) {
	buf := make([]*model.Market, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m marketDo) FindInBatches(result *[]*model.Market, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m marketDo) Attrs(attrs ...field.AssignExpr) *marketDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m marketDo) Assign(attrs ...field.AssignExpr) *marketDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m marketDo) Joins(fields ...field.RelationField) *marketDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m marketDo) Preload(fields ...field.RelationField) *marketDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m marketDo) FirstOrInit() (*model.Market, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Market), nil
	}
}

func (m marketDo) FirstOrCreate() (*model.Market, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Market), nil
	}
}

func (m marketDo) FindByPage(offset int, limit int) (result []*model.Market, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m marketDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m marketDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m marketDo) Delete(models ...*model.Market) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *marketDo) withDO(do gen.Dao) *marketDo {
	m.DO = *do.(*gen.DO)
	return m
}
